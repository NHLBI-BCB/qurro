import json
import skbio
from pytest import approx


def basic_vegalite_json_validation(json_obj):
    """Basic validations of Vega-Lite JSON objects go here."""
    assert json_obj["$schema"].startswith("https://vega.github.io/schema")
    assert json_obj["$schema"].endswith(".json")


def ordination_to_rank_dict(ordination_file_loc):
    """Converts an ordination.txt file to an easily usable dict format.

    Arguments:

    ordination_file_loc: str
        Location of an ordination file generated by DEICODE, in which "Species"
        (features) correspond to taxa/metabolites.

        NOTE that we don't care what each feature ID is so long as it's unique.
        Some examples of common types of IDs used here:
            -a short (100bp) DNA sequence (as in the DEICODE ordination files)
            -a full or partial taxonomy
            -a metabolite ID

    Returns:

    ranked_features: dict
        dict mapping each taxon/metabolite ID in beta.csv to an ordered tuple
        of its given rank values.
    """
    ordination = skbio.OrdinationResults.read(ordination_file_loc)
    ranked_features = {}
    for feature_row in ordination.features.itertuples():
        # feature_row[0] (which is the index of this row in the
        # ordination.features pandas DataFrame) corresponds to the
        # taxon/metabolite ID. feature_row[1:] correspond to this row's values:
        # that is, its ranks.
        #
        # Ensure that this ID isn't used twice. If it is, we've got problems.
        # (TODO: roll this check into the main codebase #50)
        assert feature_row[0] not in ranked_features
        ranked_features[feature_row[0]] = feature_row[1:]
    return ranked_features


def beta_csv_to_rank_dict(beta_csv_loc):
    """Converts a beta.csv file to an easily usable dict format.

    Arguments:

    beta_csv_loc: str
        Location of a beta.csv file generated by songbird.

    Returns:

    ranked_features: dict
        dict mapping each taxon/metabolite ID in beta.csv to an ordered list of
        its given rank values.
    """

    ranked_features = {}
    first_line = True
    with open(beta_csv_loc, 'r') as inrankfile:
        for line in inrankfile:
            if first_line:
                # The first line just contains headers
                first_line = False
                continue
            feature_row = line.strip().split(",")
            # Ensure that this ID isn't used twice
            assert feature_row[0] not in ranked_features
            # The first column in the file contains the taxon ID
            ranks = [float(rank) for rank in feature_row[1:]]
            ranked_features[feature_row[0]] = ranks
    return ranked_features


def validate_rank_plot_json(input_ranks_loc, rank_json_loc):
    # Record all taxa and the requested rank value in the input ranks file
    # TODO: validate rank plot json against actual ranks (in ranked_features)
    # -- that is, verify that ordering of ranks and their indices matches
    # ranked_features, etc. Can extend the loop below i think

    deicode_ordination = True
    if input_ranks_loc.endswith("beta.csv"):
        ranked_features = beta_csv_to_rank_dict(input_ranks_loc)
        deicode_ordination = False
    else:
        ranked_features = ordination_to_rank_dict(input_ranks_loc)

    # Validate the rank plot JSON.
    with open(rank_json_loc, "r") as rank_plot_file:
        rank_plot = json.load(rank_plot_file)
        # Validate some basic properties of the plot
        # (This is all handled by Altair, so these property tests aren't
        # exhaustive; they're mainly intended to verify that a general plot
        # matching our specs is being created)
        assert rank_plot["mark"] == "bar"
        assert rank_plot["title"] == "Ranks"
        basic_vegalite_json_validation(rank_plot)
        dn = rank_plot["data"]["name"]
        # Check that we have the same count of ranks as in the input ranks file
        assert len(rank_plot["datasets"][dn]) == len(ranked_features)
        # Loop over every rank included in this JSON file:
        prev_coefs_val = float("-inf")
        prev_x_val = -1
        for rank in rank_plot["datasets"][dn]:
            # Check that we're using the correct "coefs" value
            # We use pytest's approx class to get past floating point
            # imprecisions. Note that we just leave this at the default for
            # approx, so if this starts failing then adjusting the tolerances
            # in approx() might be needed.
            if deicode_ordination:
                # NOTE Based on how we construct feature labels from DEICODE
                # input. If that changes, this will need to change or this
                # will break.
                feature_id = rank["index"].split("|")[2]
            else:
                feature_id = rank["index"]
            # NOTE This assumes that the 0-th rank (i.e. the first) is the one
            # stored in the rank plot. When we eventually update this so that
            # an arbitrary number of ranks for each feature are stored in the
            # rank plot, we'll need to ensure that there's a one-to-one
            # correspondence between the various "coefs" and
            # ranked_features[feature_id].
            assert ranked_features[feature_id][0] == approx(rank["coefs"])
            # Check that the ranks are in order (i.e. their "coefs" vals are
            # monotonically increasing)
            # (If this rank is approximately equal to the previous rank, then
            # don't bother with the comparison -- but still update
            # prev_coefs_val, of course.)
            if rank["coefs"] != approx(prev_coefs_val):
                assert rank["coefs"] >= prev_coefs_val
            # Check that x values are also in order
            assert rank["x"] == prev_x_val + 1
            # Update prev_ things for the next iteration of the loop
            prev_coefs_val = rank["coefs"]
            prev_x_val = rank["x"]


def validate_sample_plot_json(biom_table_loc, metadata_loc, sample_json_loc):
    with open(sample_json_loc, "r") as sampleplotfile:
        sample_plot = json.load(sampleplotfile)
        assert sample_plot["mark"] == "circle"
        assert sample_plot["title"] == "Log Ratio of Abundances in Samples"
        basic_vegalite_json_validation(sample_plot)
        # dn = sample_plot["data"]["name"]
        # TODO check that all metadata samples are accounted for in BIOM table
        # TODO check that every log ratio is correct! I guess that'll make us
        # load the rank plots file, but it's worth it (tm)
