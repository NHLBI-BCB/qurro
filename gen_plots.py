#!/usr/bin/env python3
# Generates two JSON files: one for a rank plot and one for a sample
# scatterplot of log ratios.
#
# A lot of the code for processing input data in this file was based on code
# by Jamie Morton, some of which is now located in ipynb/Figure3.ipynb in
# https://github.com/knightlab-analyses/reference-frames.
#
# NOTE: For some reason, the sample plot JSON generated here differs somehow
# from the JSON generated by the notebook I was testing this with. Seems to
# just be an ordering issue, but a TODO is to write code that validates that
# that is the case (and it isn't actually messing up any of the data/metadata).

import json
import sys
import os
import argparse
import numpy as np
import pandas as pd
from biom import load_table
import altair as alt

parser = argparse.ArgumentParser(description="""Prepares two Altair JSON plots
-- one for a rank plot of taxa, and one for a scatterplot of sample taxon
abundances -- as input for RankRatioViz' web interface.""")
parser.add_argument("-r", "--rank-file", required=True,
    help="""CSV file detailing rank values for taxa. This should be the output
    of a tool like Songbird or DEICODE.""")
parser.add_argument("-t", "--table-file", required=True,
    help="""BIOM table describing taxon abundances for samples.""")
parser.add_argument("-m", "--metadata-file", required=True,
    help="""Metadata table file for samples.""")
parser.add_argument("-d", "--output-directory", required=False,
    default=os.getcwd(),
    help="""Output directory for JSON files (defaults to CWD)""")

def process_input(ranks, biom_table, metadata):
    """Load input files: ranked taxa, BIOM table, metadata."""

    beta = pd.read_csv(ranks, index_col=0)
    table = load_table(biom_table).to_dataframe().to_dense().T
    metadata = pd.read_table(metadata, index_col=0)

    # Exclude certain samples from the plots, if requested.
    # TODO make this an option from the command line
    # WAIT NO TODO make it doable in the web interface
    sample_exclude = set(['MET0852', 'MET1504'])
    metadata = metadata.loc[set(metadata.index) - sample_exclude]

    return beta, table, metadata

def gen_rank_plot(beta, rank_col):
    """Generates JSON for the rank plot.

    Arguments:

    beta: pandas DataFrame with taxon names as index column. Contains
          multinomial ranks as other column(s).
          For information about how these ranks are generated and what they
          mean, see Morton & Marotz et al. 2018 (in submission) or
          https://github.com/knightlab-analyses/reference-frames.
    rank_col: the column index to use for getting the rank values for each
              taxon.

    Returns:

    altair.Chart object for the rank plot.
    """

    # Get stuff ready for the rank plot

    # coefs is a pandas Series
    coefs = beta[rank_col].sort_values()
    # x is a numpy ndarray
    x = np.arange(coefs.shape[0])

    # Set default classification of every taxon to "None"
    # (This value will be updated when a taxon is selected in the rank plot as
    # part of the numerator, denominator, or both parts of the current log
    # ratio.)
    classification = pd.Series(index=coefs.index).fillna("None")
    postFlareRanksData = pd.DataFrame({
        'x': x, 'coefs': coefs, "classification": classification
    })
    # NOTE: The default size value of mark_bar() causes an apparent offset in
    # the interval selection (we're not using that right now, except for the
    # .interactive() thing, though, so I don't think this is currently
    # relevant).
    #
    # Setting size to 1.0 fixes this; using mark_rule() also fixes this,
    # probably because the lines in rule charts are just lines with a width
    # of 1.0.
    postflare_rank_chart = alt.Chart(
            postFlareRanksData.reset_index(),
            title="Ranks"
    ).mark_bar().encode(
        x=alt.X('x', title="Species", type="quantitative"),
        y=alt.Y('coefs', title="log(PostFlare / Flare) + K", type="quantitative"),
        color=alt.Color("classification",
            scale=alt.Scale(
                domain=["None", "Numerator", "Denominator", "Both"],
                range=["#e0e0e0", "#f00", "#00f", "#949"]
            )
        ),
        size=alt.value(1.0),
        tooltip=["x", "coefs", "classification", "index"]
    ).configure_axis(
        # Done in order to differentiate "None"-classification taxa from grid
        # lines (an imperfect solution to the problem mentioned in the NOTE
        # below)
        gridOpacity=0.35
    ).interactive()
    return postflare_rank_chart

def gen_sample_plot(table, metadata):
    """Create Altair version of sample scatterplot.

    Arguments:

    table: pandas DataFrame describing taxon abundances for each sample.
    metadata: pandas DataFrame describing metadata for each sample.

    Returns:

    JSON (in the form of a dict) describing the sample plot.
    """

    # Since we don't bother setting a default log ratio, we set the balance for
    # every sample to NaN so that Altair will filter them out (producing an empty
    # scatterplot by default, which makes sense).
    balance = pd.Series(index=table.index).fillna(float('nan'))
    data = pd.DataFrame({'balance': balance}, index=table.index)
    data = pd.merge(data, metadata, left_index=True, right_index=True)

    # Construct unified DataFrame, combining our "data" DataFrame with the
    # "table" variable (in order to associate each sample with its corresponding
    # abundances)
    sample_metadata_and_abundances = pd.merge(
        data, table, left_index=True, right_index=True
    )

    # "Reset the index" -- make the sample IDs a column (on the leftmost side)
    sample_metadata_and_abundances.reset_index(inplace=True)

    # Make note of the column names in the unified data frame.
    # This constructs a dictionary mapping the column names to their integer
    # indices (just the range of [0, 3084]). Similarly to smaa_i2sid above,
    # we'll preserve this in the JSON.
    smaa_cols = sample_metadata_and_abundances.columns
    smaa_cn2si = {}
    int_smaa_col_names = [str(i) for i in range(len(smaa_cols))]
    for j in int_smaa_col_names:
        # (Altair doesn't seem to like accepting ints as column names, so we
        # mostly use the new column names as strings when we can.)
        smaa_cn2si[smaa_cols[int(j)]] = j

    # Now, we replace column names (which include upwards of 3,000 lineages)
    # with just the integer indices from before.
    #
    # This saves *a lot* of space in the JSON file for the sample plot, since
    # each column name is referenced once for each sample (and
    # 50 samples * (~3000 taxonomy IDs ) * (~50 characters per ID)
    # comes out to 7.5 MB, which is an underestimate).
    sample_metadata_and_abundances.columns = int_smaa_col_names

    # Create sample plot in Altair.
    sample_logratio_chart = alt.Chart(
        sample_metadata_and_abundances,
        title="Log Ratio of Abundances in Samples"
    ).mark_circle().encode(
        alt.X(smaa_cn2si["Objective SCORAD"], title="SCORAD"),
        alt.Y(smaa_cn2si["balance"], title="log(Numerator / Denominator)"),
        color=alt.Color(
            smaa_cn2si["Timepoint"],
            title="Time: Baseline / Flare / Post-Flare",
            scale=alt.Scale(
                domain=["B", "PF", "F"],
                range=["#00c", "#0c0", "#c00"]
            )
        ),
        tooltip=[smaa_cn2si["index"]]
    )#.interactive()

    # Save JSON for sample plot (including the column-identifying dict from
    # earlier).
    sample_logratio_chart_json = sample_logratio_chart.to_dict()
    sample_logratio_chart_json["datasets"]["col_names"] = smaa_cn2si
    return sample_logratio_chart_json

def run_script(cmdline_args):
    args = parser.parse_args(cmdline_args)
    print("Processing input files...")
    beta, table, metadata = process_input(args.rank_file, args.table_file,
            args.metadata_file)

    print("Creating rank plot...")
    rank_plot_chart = gen_rank_plot(beta, "C(Timepoint, Treatment('F'))[T.PF]")

    print("Creating sample log ratio scatterplot...")
    sample_plot_json = gen_sample_plot(table, metadata)

    print("Saving plot JSON files...")
    rank_plot_loc = os.path.join(args.output_directory, "rank_plot.json")
    sample_plot_loc = os.path.join(args.output_directory,
            "sample_logratio_plot.json")

    rank_plot_chart.save(rank_plot_loc)
    # For reference: https://stackoverflow.com/a/12309296
    with open(sample_plot_loc, "w") as jfile:
        json.dump(sample_plot_json, jfile)

    print("Done.")

if __name__ == '__main__':
    # Command-line argument paradigm based on MetagenomeScope's version
    # (https://github.com/marbl/MetagenomeScope)
    # (which is in turn based on https://stackoverflow.com/a/18161115)
    run_script(sys.argv[1:])
