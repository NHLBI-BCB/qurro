#!/usr/bin/env python3
# ----------------------------------------------------------------------------
# Copyright (c) 2018--, Qurro development team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file LICENSE.txt, distributed with this software.
# ----------------------------------------------------------------------------

import json
import copy
import os


def get_jsons(main_js_loc, as_dict=True, return_nones=False):
    """Extracts the plot JSONs from a main.js file generated by Qurro.

       If either JSON isn't available, raises a ValueError unless
       return_nones is True (in which case nonexistent plots will be
       represented by a None in the output).

       Parameters
       ----------
       main_js_loc: str
          The location of a main.js file, which should contain assignments
          to the rankPlotJSON and samplePlotJSON (local) variables. We make
          the assumption that some of the lines in this file are written as
          follows:

          [optional whitespace]var rankPlotJSON = {1};[optional whitespace]
          [optional whitespace]var samplePlotJSON = {2};[optional whitespace]
          [optional whitespace]var countJSON = {3};[optional whitespace]

          where {1} is the rank plot JSON, {2} is the sample plot JSON, and {3}
          is the count JSON (this one doesn't define a plot, it just specifies
          the feature counts for each sample).

          This function just extracts {1}, {2}, and {3} and returns the JSONs
          as either dicts or strings.

       as_dict: bool
          If True, this will load the JSONs as dicts by calling json.loads().
          If False, this will just return the strings.

       return_nones: bool
          If False, this will raise a ValueError if a declaration of either
          JSON is not found in the main.js file.
          If True, this will just return None(s) in place of the corresponding
          missing JSON(s).

       Returns
       -------
       (rank_plot, sample_plot, count_json): each plot could be a dict, str,
                                             or None

          By default this returns (dict, dict, dict). Passing as_dict=False
          will cause (str, str, str) to be returned instead. Passing
          return_nones=True will allow Nones to be in the output (so
          l(None, None), (dict, None),
          (None, str), etc. are all possible outputs).
    """
    rank_plot_json_str = None
    sample_plot_json_str = None
    count_json_str = None
    with open(main_js_loc, "r") as mf:
        for line in mf:
            # Use strip() to trim off starting and trailing whitespace; use the
            # first position in the slice to ignore the
            # "var [rank/sample]PlotJSON = " stuff; use the second position in
            # the slice (-1) to remove the trailing semicolon
            if line.lstrip().startswith("var rankPlotJSON = "):
                rank_plot_json_str = line.strip()[19:-1]
            elif line.lstrip().startswith("var samplePlotJSON = "):
                sample_plot_json_str = line.strip()[21:-1]
            elif line.lstrip().startswith("var countJSON = "):
                count_json_str = line.strip()[16:-1]
                break

    if (
        rank_plot_json_str is None
        or sample_plot_json_str is None
        or count_json_str is None
    ):
        if not return_nones:
            raise ValueError("Plot JSONs not found in {}.".format(main_js_loc))

    if as_dict:

        def str_to_json(s):
            if s is None:
                return None
            else:
                return json.loads(s)

        return (
            str_to_json(rank_plot_json_str),
            str_to_json(sample_plot_json_str),
            str_to_json(count_json_str),
        )
    else:
        return rank_plot_json_str, sample_plot_json_str, count_json_str


def plot_jsons_equal(json1, json2):
    """Determines if two Vega-Lite JSON objects are effectively equal.

       This attempts to "standardize" the name assigned by Altair to the
       datasets (which is somehow based on a hash of the input dataset).
       I've noticed that this can vary even when the data is otherwise
       similar, if the two JSONs only differ by this name then this will
       consider them equal.
    """
    try:
        dn1 = json1["data"]["name"]
        dn2 = json2["data"]["name"]
    except (KeyError, TypeError):
        # At least one of the JSONs didn't have a set data name. Or it was
        # None. However, the inputs could still ostensibly be equal --
        # e.g. they're both {} or both None or something
        return json1 == json2
    test_dn = "qurro_test_dataname"
    # Avoid modifying json1 and json2 by creating deep copies of them.
    # Use of copy.deepcopy() based on
    # https://www.peterbe.com/plog/be-careful-with-using-dict-to-create-a-copy
    json1_c = copy.deepcopy(json1)
    json2_c = copy.deepcopy(json2)
    json1_c["data"]["name"] = test_dn
    json2_c["data"]["name"] = test_dn
    # https://stackoverflow.com/a/16475444
    json1_c["datasets"][test_dn] = json1_c["datasets"].pop(dn1)
    json2_c["datasets"][test_dn] = json2_c["datasets"].pop(dn2)
    return json1_c == json2_c


def replace_js_plot_json_definitions(
    input_file_loc,
    rank_plot_json,
    sample_plot_json,
    count_json,
    output_file_loc=None,
):
    """Writes a version of the input JS file with plot JSON(s) changed.

       If output_file_loc is None, the input_file_loc will be overwritten.

       If neither plot JSON is different, this won't write anything to the
       output file (or the input file, if output_file_loc is None). This
       function will return 1 in this case, and will return 0 otherwise.

       Note that the JS variable names defined here (rankPlotJSON,
       samplePlotJSON, and countJSON), as well as these variables being defined
       on separate lines of the file, are relied on in the python tests when
       extracting the JSON files from generated main.js files. If you change
       the way these variables are written to in the JS, it may cause the
       python tests to fail.
    """

    curr_rank_plot_json, curr_sample_plot_json, curr_count_json = get_jsons(
        input_file_loc, return_nones=True
    )
    output_file_contents = ""
    at_least_one_plot_changed = False
    with open(input_file_loc, "r") as input_file_obj:
        # read in basic main.js contents. Replace {}s in definitions of the
        # plot JSONs with the actual JSON.
        for line in input_file_obj:
            output_line = line
            if line.lstrip().startswith("var rankPlotJSON = {"):
                if not plot_jsons_equal(curr_rank_plot_json, rank_plot_json):
                    output_line = (
                        output_line[: output_line.index("{")]
                        + json.dumps(rank_plot_json)
                        + ";\n"
                    )
                    at_least_one_plot_changed = True
            elif line.lstrip().startswith("var samplePlotJSON = {"):
                if not plot_jsons_equal(
                    curr_sample_plot_json, sample_plot_json
                ):
                    output_line = (
                        output_line[: output_line.index("{")]
                        + json.dumps(sample_plot_json)
                        + ";\n"
                    )
                    at_least_one_plot_changed = True
            elif line.lstrip().startswith("var countJSON = {"):
                if not plot_jsons_equal(curr_count_json, count_json):
                    output_line = (
                        output_line[: output_line.index("{")]
                        + json.dumps(count_json)
                        + ";\n"
                    )
                    at_least_one_plot_changed = True
            output_file_contents += output_line

    if at_least_one_plot_changed:
        if output_file_loc is None:
            output_file_loc = input_file_loc

        with open(output_file_loc, "w") as output_file_obj:
            output_file_obj.write(output_file_contents)
        return 0
    # Let the caller know that nothing was written to the output file location.
    # If this was called on a JS test then this perfectly normal, but if this
    # was called during the execution of Qurro then this is a problem.
    return 1


if __name__ == "__main__":
    """Update JSON plot definitions for the Qurro web tests."""
    test_dir = os.path.join("qurro", "tests", "web_tests", "tests")
    rrv_js_tests = filter(lambda f: f.endswith(".js"), os.listdir(test_dir))
    rank_plot_json, sample_plot_json, count_json = get_jsons(
        os.path.join("docs", "demos", "matching_test", "main.js")
    )
    for js_test_file in rrv_js_tests:
        replace_js_plot_json_definitions(
            os.path.join(test_dir, js_test_file),
            rank_plot_json,
            sample_plot_json,
            count_json,
        )
